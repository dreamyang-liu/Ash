# =============================================================================
# Ash Infrastructure - AWS EKS Configuration
# =============================================================================
# Prerequisites:
#   - EKS cluster with nodegroup labeled: eks.amazonaws.com/nodegroup=infra
#   - Namespace 'ash' exists
#   - ServiceAccount 'control-plane' exists with proper RBAC
#
# Usage:
#   kubectl apply -f infra.yaml
# =============================================================================

# -----------------------------------------------------------------------------
# ConfigMap - Centralized Configuration
# -----------------------------------------------------------------------------
apiVersion: v1
kind: ConfigMap
metadata:
  name: ash-config
  namespace: ash
  labels:
    app.kubernetes.io/name: ash
    app.kubernetes.io/part-of: ash
data:
  TARGET_NAMESPACE: "ash"
  REDIS_HOST: "redis.ash.svc.cluster.local"
  REDIS_PORT: "6379"
  REDIS_DB: "0"
  REDIS_ADDR: "redis.ash.svc.cluster.local:6379"
  # Gateway timeout settings (Go duration format: "5m", "300s", etc.)
  REQUEST_TIMEOUT: "5m"      # Per-request timeout
  READ_TIMEOUT: "6m"         # HTTP server read timeout (must be > REQUEST_TIMEOUT)
  WRITE_TIMEOUT: "6m"        # HTTP server write timeout (must be > REQUEST_TIMEOUT)
  IDLE_TIMEOUT: "5m"         # HTTP server idle connection timeout
---

# -----------------------------------------------------------------------------
# Redis - State Store
# -----------------------------------------------------------------------------
apiVersion: v1
kind: Service
metadata:
  name: redis
  namespace: ash
  labels:
    app: redis
    app.kubernetes.io/name: redis
    app.kubernetes.io/component: state-store
    app.kubernetes.io/part-of: ash
spec:
  type: ClusterIP
  selector:
    app: redis
  ports:
    - name: redis
      port: 6379
      targetPort: 6379
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: redis
  namespace: ash
  labels:
    app: redis
    app.kubernetes.io/name: redis
    app.kubernetes.io/component: state-store
    app.kubernetes.io/part-of: ash
spec:
  replicas: 1
  strategy:
    type: Recreate  # Redis is single-instance, avoid data conflicts
  selector:
    matchLabels:
      app: redis
  template:
    metadata:
      labels:
        app: redis
        app.kubernetes.io/name: redis
        app.kubernetes.io/component: state-store
        app.kubernetes.io/part-of: ash
    spec:
      nodeSelector:
        eks.amazonaws.com/nodegroup: infra
      securityContext:
        runAsNonRoot: true
        runAsUser: 999
        runAsGroup: 999
        fsGroup: 999
      containers:
        - name: redis
          image: redis:7-alpine
          imagePullPolicy: IfNotPresent
          args:
            - "redis-server"
            - "--appendonly"
            - "yes"
            - "--save"
            - "900"
            - "1"
            - "--save"
            - "300"
            - "10"
            - "--protected-mode"
            - "no"
            - "--maxmemory"
            - "512mb"
            - "--maxmemory-policy"
            - "allkeys-lru"
            - "--tcp-keepalive"
            - "60"
            - "--timeout"
            - "0"
          ports:
            - containerPort: 6379
              name: redis
          securityContext:
            allowPrivilegeEscalation: false
            readOnlyRootFilesystem: false  # Redis needs to write AOF/RDB
            capabilities:
              drop:
                - ALL
          resources:
            requests:
              cpu: "500m"
              memory: "512Mi"
            limits:
              cpu: "1000m"
              memory: "1Gi"
          livenessProbe:
            exec:
              command:
                - redis-cli
                - ping
            initialDelaySeconds: 10
            periodSeconds: 10
            timeoutSeconds: 5
            failureThreshold: 3
          readinessProbe:
            exec:
              command:
                - redis-cli
                - ping
            initialDelaySeconds: 5
            periodSeconds: 5
            timeoutSeconds: 3
          volumeMounts:
            - name: redis-data
              mountPath: /data
      volumes:
        # Use PVC for data persistence. Fall back to emptyDir if PVC not available.
        - name: redis-data
          emptyDir:
            sizeLimit: 1Gi
        # Uncomment below and comment emptyDir above for persistent storage:
        # - name: redis-data
        #   persistentVolumeClaim:
        #     claimName: redis-data-pvc
---
# Optional: PersistentVolumeClaim for Redis (uncomment if needed)
# apiVersion: v1
# kind: PersistentVolumeClaim
# metadata:
#   name: redis-data-pvc
#   namespace: ash
#   labels:
#     app.kubernetes.io/name: redis
#     app.kubernetes.io/part-of: ash
# spec:
#   accessModes:
#     - ReadWriteOnce
#   storageClassName: gp3  # EKS default, change as needed
#   resources:
#     requests:
#       storage: 5Gi
# ---

# -----------------------------------------------------------------------------
# Control Plane - Sandbox Lifecycle Manager
# -----------------------------------------------------------------------------
apiVersion: apps/v1
kind: Deployment
metadata:
  name: control-plane
  namespace: ash
  labels:
    app: control-plane
    app.kubernetes.io/name: control-plane
    app.kubernetes.io/component: lifecycle-manager
    app.kubernetes.io/part-of: ash
spec:
  replicas: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 1
  selector:
    matchLabels:
      app: control-plane
  template:
    metadata:
      labels:
        app: control-plane
        app.kubernetes.io/name: control-plane
        app.kubernetes.io/component: lifecycle-manager
        app.kubernetes.io/part-of: ash
    spec:
      serviceAccountName: control-plane
      nodeSelector:
        eks.amazonaws.com/nodegroup: infra
      # Spread replicas across nodes for HA
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - weight: 100
              podAffinityTerm:
                labelSelector:
                  matchLabels:
                    app: control-plane
                topologyKey: kubernetes.io/hostname
      securityContext:
        runAsNonRoot: true
        runAsUser: 1000
        runAsGroup: 1000
      # Wait for Redis before starting
      initContainers:
        - name: wait-for-redis
          image: busybox:1.36
          command:
            - sh
            - -c
            - |
              echo "Waiting for Redis at redis.ash.svc.cluster.local:6379..."
              until nc -z redis.ash.svc.cluster.local 6379; do
                echo "Redis not ready, retrying in 2s..."
                sleep 2
              done
              echo "Redis is ready!"
          securityContext:
            allowPrivilegeEscalation: false
            readOnlyRootFilesystem: true
            capabilities:
              drop:
                - ALL
          resources:
            requests:
              cpu: "50m"
              memory: "32Mi"
            limits:
              cpu: "100m"
              memory: "64Mi"
      containers:
        - name: control-plane
          image: timemagic/ash:control-plane-0.1
          imagePullPolicy: Always
          envFrom:
            - configMapRef:
                name: ash-config
          ports:
            - containerPort: 8080
              name: http
          securityContext:
            allowPrivilegeEscalation: false
            readOnlyRootFilesystem: true
            capabilities:
              drop:
                - ALL
          resources:
            requests:
              cpu: "250m"
              memory: "256Mi"
            limits:
              cpu: "1000m"
              memory: "512Mi"
          livenessProbe:
            httpGet:
              path: /healthz
              port: 8080
            initialDelaySeconds: 15
            periodSeconds: 20
            timeoutSeconds: 5
            failureThreshold: 3
          readinessProbe:
            httpGet:
              path: /readyz
              port: 8080
            initialDelaySeconds: 5
            periodSeconds: 10
            timeoutSeconds: 5
            failureThreshold: 3
      terminationGracePeriodSeconds: 30
---
apiVersion: v1
kind: Service
metadata:
  name: control-plane
  namespace: ash
  labels:
    app: control-plane
    app.kubernetes.io/name: control-plane
    app.kubernetes.io/component: lifecycle-manager
    app.kubernetes.io/part-of: ash
spec:
  type: LoadBalancer
  selector:
    app: control-plane
  ports:
    - name: http
      port: 80
      targetPort: 8080
---

# -----------------------------------------------------------------------------
# Gateway - Request Router / Reverse Proxy
# -----------------------------------------------------------------------------
apiVersion: apps/v1
kind: Deployment
metadata:
  name: gateway
  namespace: ash
  labels:
    app: gateway
    app.kubernetes.io/name: gateway
    app.kubernetes.io/component: api-gateway
    app.kubernetes.io/part-of: ash
spec:
  replicas: 2
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  selector:
    matchLabels:
      app: gateway
  template:
    metadata:
      labels:
        app: gateway
        app.kubernetes.io/name: gateway
        app.kubernetes.io/component: api-gateway
        app.kubernetes.io/part-of: ash
    spec:
      nodeSelector:
        eks.amazonaws.com/nodegroup: infra
      # Spread replicas across nodes for HA
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - weight: 100
              podAffinityTerm:
                labelSelector:
                  matchLabels:
                    app: gateway
                topologyKey: kubernetes.io/hostname
      securityContext:
        runAsNonRoot: true
        runAsUser: 1000
        runAsGroup: 1000
      initContainers:
        - name: wait-for-redis
          image: busybox:1.36
          command:
            - sh
            - -c
            - |
              echo "Waiting for Redis at redis.ash.svc.cluster.local:6379..."
              until nc -z redis.ash.svc.cluster.local 6379; do
                echo "Redis not ready, retrying in 2s..."
                sleep 2
              done
              echo "Redis is ready!"
          securityContext:
            allowPrivilegeEscalation: false
            readOnlyRootFilesystem: true
            capabilities:
              drop:
                - ALL
          resources:
            requests:
              cpu: "50m"
              memory: "32Mi"
            limits:
              cpu: "100m"
              memory: "64Mi"
      containers:
        - name: gateway
          image: timemagic/ash:gateway-0.1
          imagePullPolicy: Always
          envFrom:
            - configMapRef:
                name: ash-config
          ports:
            - containerPort: 8080
              name: http
          securityContext:
            allowPrivilegeEscalation: false
            readOnlyRootFilesystem: true
            capabilities:
              drop:
                - ALL
          resources:
            requests:
              cpu: "500m"
              memory: "512Mi"
            limits:
              cpu: "2000m"
              memory: "2Gi"
          livenessProbe:
            httpGet:
              path: /healthz
              port: 8080
            initialDelaySeconds: 10
            periodSeconds: 15
            timeoutSeconds: 5
            failureThreshold: 3
          readinessProbe:
            httpGet:
              path: /healthz
              port: 8080
            initialDelaySeconds: 5
            periodSeconds: 10
            timeoutSeconds: 5
            failureThreshold: 3
      terminationGracePeriodSeconds: 60  # Allow time for SSE connections to drain
---
apiVersion: v1
kind: Service
metadata:
  name: gateway
  namespace: ash
  labels:
    app: gateway
    app.kubernetes.io/name: gateway
    app.kubernetes.io/component: api-gateway
    app.kubernetes.io/part-of: ash
  annotations:
    # EKS/ALB annotations - 5 minute connection timeout
    service.beta.kubernetes.io/aws-load-balancer-connection-idle-timeout: "300"
spec:
  type: LoadBalancer
  selector:
    app: gateway
  ports:
    - name: http
      port: 80
      targetPort: 8080
---

# -----------------------------------------------------------------------------
# PodDisruptionBudgets - Ensure HA during maintenance
# -----------------------------------------------------------------------------
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: control-plane-pdb
  namespace: ash
  labels:
    app.kubernetes.io/name: control-plane
    app.kubernetes.io/part-of: ash
spec:
  minAvailable: 2
  selector:
    matchLabels:
      app: control-plane
---
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: gateway-pdb
  namespace: ash
  labels:
    app.kubernetes.io/name: gateway
    app.kubernetes.io/part-of: ash
spec:
  minAvailable: 1
  selector:
    matchLabels:
      app: gateway
---
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: redis-pdb
  namespace: ash
  labels:
    app.kubernetes.io/name: redis
    app.kubernetes.io/part-of: ash
spec:
  minAvailable: 1
  selector:
    matchLabels:
      app: redis
